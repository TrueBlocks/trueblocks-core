# coding: utf-8

"""


    Generated by: https://openapi-generator.tech
"""

from dataclasses import dataclass
import typing_extensions
import urllib3
from urllib3._collections import HTTPHeaderDict

from openapi_client import api_client, exceptions
from datetime import date, datetime  # noqa: F401
import decimal  # noqa: F401
import functools  # noqa: F401
import io  # noqa: F401
import re  # noqa: F401
import typing  # noqa: F401
import typing_extensions  # noqa: F401
import uuid  # noqa: F401

import frozendict  # noqa: F401

from openapi_client import schemas  # noqa: F401

from . import path

# Query params
AddrsSchema = schemas.AnyTypeSchema
TopicsSchema = schemas.AnyTypeSchema
FourbytesSchema = schemas.AnyTypeSchema
AppearancesSchema = schemas.AnyTypeSchema
ReceiptsSchema = schemas.AnyTypeSchema
LogsSchema = schemas.AnyTypeSchema
TracesSchema = schemas.AnyTypeSchema
NeighborsSchema = schemas.AnyTypeSchema
AccountingSchema = schemas.AnyTypeSchema
StatementsSchema = schemas.AnyTypeSchema
BalancesSchema = schemas.AnyTypeSchema
ArticulateSchema = schemas.AnyTypeSchema
CacheTracesSchema = schemas.AnyTypeSchema
CountSchema = schemas.AnyTypeSchema


class FirstRecordSchema(
    schemas.AnyTypeSchema,
):


    class MetaOapg:
        format = 'uint64'


    def __new__(
        cls,
        *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'FirstRecordSchema':
        return super().__new__(
            cls,
            *_args,
            _configuration=_configuration,
            **kwargs,
        )


class MaxRecordsSchema(
    schemas.AnyTypeSchema,
):


    class MetaOapg:
        format = 'uint64'


    def __new__(
        cls,
        *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'MaxRecordsSchema':
        return super().__new__(
            cls,
            *_args,
            _configuration=_configuration,
            **kwargs,
        )
RelevantSchema = schemas.AnyTypeSchema
EmitterSchema = schemas.AnyTypeSchema
TopicSchema = schemas.AnyTypeSchema
AssetSchema = schemas.AnyTypeSchema


class FlowSchema(
    schemas.AnyTypeSchema,
):


    class MetaOapg:
        enum_value_to_name = {
            "in": "IN",
            "out": "OUT",
            "zero": "ZERO",
        }
    
    @schemas.classproperty
    def IN(cls):
        return cls("in")
    
    @schemas.classproperty
    def OUT(cls):
        return cls("out")
    
    @schemas.classproperty
    def ZERO(cls):
        return cls("zero")


    def __new__(
        cls,
        *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'FlowSchema':
        return super().__new__(
            cls,
            *_args,
            _configuration=_configuration,
            **kwargs,
        )
FactorySchema = schemas.AnyTypeSchema
UnripeSchema = schemas.AnyTypeSchema
ReversedSchema = schemas.AnyTypeSchema
NoZeroSchema = schemas.AnyTypeSchema


class FirstBlockSchema(
    schemas.AnyTypeSchema,
):


    class MetaOapg:
        format = 'blknum'


    def __new__(
        cls,
        *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'FirstBlockSchema':
        return super().__new__(
            cls,
            *_args,
            _configuration=_configuration,
            **kwargs,
        )


class LastBlockSchema(
    schemas.AnyTypeSchema,
):


    class MetaOapg:
        format = 'blknum'


    def __new__(
        cls,
        *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'LastBlockSchema':
        return super().__new__(
            cls,
            *_args,
            _configuration=_configuration,
            **kwargs,
        )
EtherSchema = schemas.AnyTypeSchema
CacheSchema = schemas.AnyTypeSchema
RequestRequiredQueryParams = typing_extensions.TypedDict(
    'RequestRequiredQueryParams',
    {
        'addrs': typing.Union[AddrsSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
    }
)
RequestOptionalQueryParams = typing_extensions.TypedDict(
    'RequestOptionalQueryParams',
    {
        'topics': typing.Union[TopicsSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'fourbytes': typing.Union[FourbytesSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'appearances': typing.Union[AppearancesSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'receipts': typing.Union[ReceiptsSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'logs': typing.Union[LogsSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'traces': typing.Union[TracesSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'neighbors': typing.Union[NeighborsSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'accounting': typing.Union[AccountingSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'statements': typing.Union[StatementsSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'balances': typing.Union[BalancesSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'articulate': typing.Union[ArticulateSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'cacheTraces': typing.Union[CacheTracesSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'count': typing.Union[CountSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'firstRecord': typing.Union[FirstRecordSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'maxRecords': typing.Union[MaxRecordsSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'relevant': typing.Union[RelevantSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'emitter': typing.Union[EmitterSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'topic': typing.Union[TopicSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'asset': typing.Union[AssetSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'flow': typing.Union[FlowSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'factory': typing.Union[FactorySchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'unripe': typing.Union[UnripeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'reversed': typing.Union[ReversedSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'noZero': typing.Union[NoZeroSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'firstBlock': typing.Union[FirstBlockSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'lastBlock': typing.Union[LastBlockSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'ether': typing.Union[EtherSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        'cache': typing.Union[CacheSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
    },
    total=False
)


class RequestQueryParams(RequestRequiredQueryParams, RequestOptionalQueryParams):
    pass


request_query_addrs = api_client.QueryParameter(
    name="addrs",
    style=api_client.ParameterStyle.FORM,
    schema=AddrsSchema,
    required=True,
    explode=True,
)
request_query_topics = api_client.QueryParameter(
    name="topics",
    style=api_client.ParameterStyle.FORM,
    schema=TopicsSchema,
    explode=True,
)
request_query_fourbytes = api_client.QueryParameter(
    name="fourbytes",
    style=api_client.ParameterStyle.FORM,
    schema=FourbytesSchema,
    explode=True,
)
request_query_appearances = api_client.QueryParameter(
    name="appearances",
    style=api_client.ParameterStyle.FORM,
    schema=AppearancesSchema,
    explode=True,
)
request_query_receipts = api_client.QueryParameter(
    name="receipts",
    style=api_client.ParameterStyle.FORM,
    schema=ReceiptsSchema,
    explode=True,
)
request_query_logs = api_client.QueryParameter(
    name="logs",
    style=api_client.ParameterStyle.FORM,
    schema=LogsSchema,
    explode=True,
)
request_query_traces = api_client.QueryParameter(
    name="traces",
    style=api_client.ParameterStyle.FORM,
    schema=TracesSchema,
    explode=True,
)
request_query_neighbors = api_client.QueryParameter(
    name="neighbors",
    style=api_client.ParameterStyle.FORM,
    schema=NeighborsSchema,
    explode=True,
)
request_query_accounting = api_client.QueryParameter(
    name="accounting",
    style=api_client.ParameterStyle.FORM,
    schema=AccountingSchema,
    explode=True,
)
request_query_statements = api_client.QueryParameter(
    name="statements",
    style=api_client.ParameterStyle.FORM,
    schema=StatementsSchema,
    explode=True,
)
request_query_balances = api_client.QueryParameter(
    name="balances",
    style=api_client.ParameterStyle.FORM,
    schema=BalancesSchema,
    explode=True,
)
request_query_articulate = api_client.QueryParameter(
    name="articulate",
    style=api_client.ParameterStyle.FORM,
    schema=ArticulateSchema,
    explode=True,
)
request_query_cache_traces = api_client.QueryParameter(
    name="cacheTraces",
    style=api_client.ParameterStyle.FORM,
    schema=CacheTracesSchema,
    explode=True,
)
request_query_count = api_client.QueryParameter(
    name="count",
    style=api_client.ParameterStyle.FORM,
    schema=CountSchema,
    explode=True,
)
request_query_first_record = api_client.QueryParameter(
    name="firstRecord",
    style=api_client.ParameterStyle.FORM,
    schema=FirstRecordSchema,
    explode=True,
)
request_query_max_records = api_client.QueryParameter(
    name="maxRecords",
    style=api_client.ParameterStyle.FORM,
    schema=MaxRecordsSchema,
    explode=True,
)
request_query_relevant = api_client.QueryParameter(
    name="relevant",
    style=api_client.ParameterStyle.FORM,
    schema=RelevantSchema,
    explode=True,
)
request_query_emitter = api_client.QueryParameter(
    name="emitter",
    style=api_client.ParameterStyle.FORM,
    schema=EmitterSchema,
    explode=True,
)
request_query_topic = api_client.QueryParameter(
    name="topic",
    style=api_client.ParameterStyle.FORM,
    schema=TopicSchema,
    explode=True,
)
request_query_asset = api_client.QueryParameter(
    name="asset",
    style=api_client.ParameterStyle.FORM,
    schema=AssetSchema,
    explode=True,
)
request_query_flow = api_client.QueryParameter(
    name="flow",
    style=api_client.ParameterStyle.FORM,
    schema=FlowSchema,
    explode=True,
)
request_query_factory = api_client.QueryParameter(
    name="factory",
    style=api_client.ParameterStyle.FORM,
    schema=FactorySchema,
    explode=True,
)
request_query_unripe = api_client.QueryParameter(
    name="unripe",
    style=api_client.ParameterStyle.FORM,
    schema=UnripeSchema,
    explode=True,
)
request_query_reversed = api_client.QueryParameter(
    name="reversed",
    style=api_client.ParameterStyle.FORM,
    schema=ReversedSchema,
    explode=True,
)
request_query_no_zero = api_client.QueryParameter(
    name="noZero",
    style=api_client.ParameterStyle.FORM,
    schema=NoZeroSchema,
    explode=True,
)
request_query_first_block = api_client.QueryParameter(
    name="firstBlock",
    style=api_client.ParameterStyle.FORM,
    schema=FirstBlockSchema,
    explode=True,
)
request_query_last_block = api_client.QueryParameter(
    name="lastBlock",
    style=api_client.ParameterStyle.FORM,
    schema=LastBlockSchema,
    explode=True,
)
request_query_ether = api_client.QueryParameter(
    name="ether",
    style=api_client.ParameterStyle.FORM,
    schema=EtherSchema,
    explode=True,
)
request_query_cache = api_client.QueryParameter(
    name="cache",
    style=api_client.ParameterStyle.FORM,
    schema=CacheSchema,
    explode=True,
)


class SchemaFor200ResponseBodyApplicationJson(
    schemas.AnyTypeSchema,
):


    class MetaOapg:
        
        class properties:
            data = schemas.AnyTypeSchema
            __annotations__ = {
                "data": data,
            }

    
    @typing.overload
    def __getitem__(self, name: typing_extensions.Literal["data"]) -> MetaOapg.properties.data: ...
    
    @typing.overload
    def __getitem__(self, name: str) -> schemas.UnsetAnyTypeSchema: ...
    
    def __getitem__(self, name: typing.Union[typing_extensions.Literal["data", ], str]):
        # dict_instance[name] accessor
        return super().__getitem__(name)
    
    
    @typing.overload
    def get_item_oapg(self, name: typing_extensions.Literal["data"]) -> typing.Union[MetaOapg.properties.data, schemas.Unset]: ...
    
    @typing.overload
    def get_item_oapg(self, name: str) -> typing.Union[schemas.UnsetAnyTypeSchema, schemas.Unset]: ...
    
    def get_item_oapg(self, name: typing.Union[typing_extensions.Literal["data", ], str]):
        return super().get_item_oapg(name)
    

    def __new__(
        cls,
        *_args: typing.Union[dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, ],
        data: typing.Union[MetaOapg.properties.data, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, bool, None, list, tuple, bytes, io.FileIO, io.BufferedReader, schemas.Unset] = schemas.unset,
        _configuration: typing.Optional[schemas.Configuration] = None,
        **kwargs: typing.Union[schemas.AnyTypeSchema, dict, frozendict.frozendict, str, date, datetime, uuid.UUID, int, float, decimal.Decimal, None, list, tuple, bytes],
    ) -> 'SchemaFor200ResponseBodyApplicationJson':
        return super().__new__(
            cls,
            *_args,
            data=data,
            _configuration=_configuration,
            **kwargs,
        )


@dataclass
class ApiResponseFor200(api_client.ApiResponse):
    response: urllib3.HTTPResponse
    body: typing.Union[
        SchemaFor200ResponseBodyApplicationJson,
    ]
    headers: schemas.Unset = schemas.unset


_response_for_200 = api_client.OpenApiResponse(
    response_cls=ApiResponseFor200,
    content={
        'application/json': api_client.MediaType(
            schema=SchemaFor200ResponseBodyApplicationJson),
    },
)


@dataclass
class ApiResponseFor400(api_client.ApiResponse):
    response: urllib3.HTTPResponse
    body: schemas.Unset = schemas.unset
    headers: schemas.Unset = schemas.unset


_response_for_400 = api_client.OpenApiResponse(
    response_cls=ApiResponseFor400,
)
_status_code_to_response = {
    '200': _response_for_200,
    '400': _response_for_400,
}
_all_accept_content_types = (
    'application/json',
)


class BaseApi(api_client.Api):
    @typing.overload
    def _accounts_export_oapg(
        self,
        query_params: RequestQueryParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
        skip_deserialization: typing_extensions.Literal[False] = ...,
    ) -> typing.Union[
        ApiResponseFor200,
    ]: ...

    @typing.overload
    def _accounts_export_oapg(
        self,
        skip_deserialization: typing_extensions.Literal[True],
        query_params: RequestQueryParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
    ) -> api_client.ApiResponseWithoutDeserialization: ...

    @typing.overload
    def _accounts_export_oapg(
        self,
        query_params: RequestQueryParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
        skip_deserialization: bool = ...,
    ) -> typing.Union[
        ApiResponseFor200,
        api_client.ApiResponseWithoutDeserialization,
    ]: ...

    def _accounts_export_oapg(
        self,
        query_params: RequestQueryParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
        skip_deserialization: bool = False,
    ):
        """
        Export details
        :param skip_deserialization: If true then api_response.response will be set but
            api_response.body and api_response.headers will not be deserialized into schema
            class instances
        """
        self._verify_typed_dict_inputs_oapg(RequestQueryParams, query_params)
        used_path = path.value

        prefix_separator_iterator = None
        for parameter in (
            request_query_addrs,
            request_query_topics,
            request_query_fourbytes,
            request_query_appearances,
            request_query_receipts,
            request_query_logs,
            request_query_traces,
            request_query_neighbors,
            request_query_accounting,
            request_query_statements,
            request_query_balances,
            request_query_articulate,
            request_query_cache_traces,
            request_query_count,
            request_query_first_record,
            request_query_max_records,
            request_query_relevant,
            request_query_emitter,
            request_query_topic,
            request_query_asset,
            request_query_flow,
            request_query_factory,
            request_query_unripe,
            request_query_reversed,
            request_query_no_zero,
            request_query_first_block,
            request_query_last_block,
            request_query_ether,
            request_query_cache,
        ):
            parameter_data = query_params.get(parameter.name, schemas.unset)
            if parameter_data is schemas.unset:
                continue
            if prefix_separator_iterator is None:
                prefix_separator_iterator = parameter.get_prefix_separator_iterator()
            serialized_data = parameter.serialize(parameter_data, prefix_separator_iterator)
            for serialized_value in serialized_data.values():
                used_path += serialized_value

        _headers = HTTPHeaderDict()
        # TODO add cookie handling
        if accept_content_types:
            for accept_content_type in accept_content_types:
                _headers.add('Accept', accept_content_type)

        response = self.api_client.call_api(
            resource_path=used_path,
            method='get'.upper(),
            headers=_headers,
            stream=stream,
            timeout=timeout,
        )

        if skip_deserialization:
            api_response = api_client.ApiResponseWithoutDeserialization(response=response)
        else:
            response_for_status = _status_code_to_response.get(str(response.status))
            if response_for_status:
                api_response = response_for_status.deserialize(response, self.api_client.configuration)
            else:
                api_response = api_client.ApiResponseWithoutDeserialization(response=response)

        if not 200 <= response.status <= 299:
            raise exceptions.ApiException(
                status=response.status,
                reason=response.reason,
                api_response=api_response
            )

        return api_response


class AccountsExport(BaseApi):
    # this class is used by api classes that refer to endpoints with operationId fn names

    @typing.overload
    def accounts_export(
        self,
        query_params: RequestQueryParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
        skip_deserialization: typing_extensions.Literal[False] = ...,
    ) -> typing.Union[
        ApiResponseFor200,
    ]: ...

    @typing.overload
    def accounts_export(
        self,
        skip_deserialization: typing_extensions.Literal[True],
        query_params: RequestQueryParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
    ) -> api_client.ApiResponseWithoutDeserialization: ...

    @typing.overload
    def accounts_export(
        self,
        query_params: RequestQueryParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
        skip_deserialization: bool = ...,
    ) -> typing.Union[
        ApiResponseFor200,
        api_client.ApiResponseWithoutDeserialization,
    ]: ...

    def accounts_export(
        self,
        query_params: RequestQueryParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
        skip_deserialization: bool = False,
    ):
        return self._accounts_export_oapg(
            query_params=query_params,
            accept_content_types=accept_content_types,
            stream=stream,
            timeout=timeout,
            skip_deserialization=skip_deserialization
        )


class ApiForget(BaseApi):
    # this class is used by api classes that refer to endpoints by path and http method names

    @typing.overload
    def get(
        self,
        query_params: RequestQueryParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
        skip_deserialization: typing_extensions.Literal[False] = ...,
    ) -> typing.Union[
        ApiResponseFor200,
    ]: ...

    @typing.overload
    def get(
        self,
        skip_deserialization: typing_extensions.Literal[True],
        query_params: RequestQueryParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
    ) -> api_client.ApiResponseWithoutDeserialization: ...

    @typing.overload
    def get(
        self,
        query_params: RequestQueryParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
        skip_deserialization: bool = ...,
    ) -> typing.Union[
        ApiResponseFor200,
        api_client.ApiResponseWithoutDeserialization,
    ]: ...

    def get(
        self,
        query_params: RequestQueryParams = frozendict.frozendict(),
        accept_content_types: typing.Tuple[str] = _all_accept_content_types,
        stream: bool = False,
        timeout: typing.Optional[typing.Union[int, typing.Tuple]] = None,
        skip_deserialization: bool = False,
    ):
        return self._accounts_export_oapg(
            query_params=query_params,
            accept_content_types=accept_content_types,
            stream=stream,
            timeout=timeout,
            skip_deserialization=skip_deserialization
        )


