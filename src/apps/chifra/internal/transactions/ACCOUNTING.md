## Concepts:

- The once reconciled, always reconciled principle: because transaction histories on a blockchain are immutable, and account's history may be reconciled once and never need to be reconciled again.  This is true even if the user changes the name of an account or token, because the history is immutable.
- If the reconciled histories were stored on an immutible store such as IPFS and the hash of the history was stored on chain, then this document could be used to determine if the history had been reconciled before.  This would be a good way to avoid having to read the history from the blockchain again.

## How to Reconcile an Account History:

- collect a complete and accurate list of all appearances (see the Specification for Unchained Index)
- for each appearance in the address's history:
  - if the reconcilation for this appearance has already been cached, then read it and return it
	- `readReconciliationFromCache`:
	    - clear the statements array in the transaction
        - if the cache item does not exist, return `false`
          - note that only fully reconciled appearances are cached
        - read the cache item into the statements array 
          - read the file
          - if the names database is newer than the cache item
            - update the asset's name
            - re-write the cache
          - return `true`
  - otherwise, create a list of all the transfers in this appearance
    - `getTransfers`:
      - using `timestamp`, `date` and `encoding` from the transaction...
      - using `accountedFor` from the context...
      - using `assetFilter` from the context...
      - for every `log` in the transaction's `receipt`:
        - if the `log's` `address` (i.e., the asset) does not pass the `assetFilter`, then
          - skip this log
        - if the `log's` `topic[0]` is not a known ERC20 token transfer, then
          - skip this log
        - `sender` = `log.topic[1]`
        - `recipient` = `log.topic[2]`
        - `amount` = `log.data`
        - `ofInterest` = `sender` == `accountedFor` || `recipient` == `accountedFor`
        - if `amount` is zero or not `ofInterest`, then 
          - skip this log
        - this is a non-zero valued transfer of interest and must be accounted for
        - load the asset's name and symbol from the names database (if found)
        - assign `timestamp`, `date`, `encoding` and other values to the transfer
        - add the transfer to the list of transfers
        - continue until no more logs
      - sort the transfers by `blockNumber`, `transactionIndex`, `logIndex`, and `assetAddress`
      - insert a `Transfer` representing the transfer of any ETH at the head of the list
      - return the list of transfers
    - We now have a list of all transfers in this transaction that must be accounted for for this address
    - for each transfer:
      - using a seperate ledger for each asset in this account's history
      - if we've seen this asset before then
        - note that asset's previous balance because we will need it to reconcile this transfer
      - else
        - note the asset's previous balance using the previous block's balance (which should be zero)
      - at this point we have previous balance for this asset
      - reconcile the flow of funds within the transaction using higher level transactional and log data
      - `reconcileFlows(transfer)`:
        - using `sender` and `recipient` from the transfer...
        - if the asset is ETH:
          - if the transactions `from` is `accountedFor`, then
            - `gasOut` = `recipt.getUsed` * `gasPrice`
          - if `sender` is `accountedFor`, then // `sender` and `from` may be different if this ETH transfer is from a trace
            - `amountOut` = the transaction's value if it did not end in an error
          - if `recipient` is `accountedFor`, then
            - recipient may be
            - `0xPrefund`:
              - `prefundIn` = the transaction's value
            - `0xBlockReward`:
              - `minerBaseRewardIn` = the base miner reward
              - `minerNephewRewardIn` = the nephew miner reward
              - `minerTxFeeIn` = the transaction fee
            - `0xUncleReward`:
              - `minerUncleRewardIn` = the uncle miner reward
            - `amountIn` = the transaction's value if it did not end in an error
          - Note that multiple of the above may be true at the same time
        - else if the asset is not an ETH transfer:
          - if `sender` is `accountedFor`, then
            - `amountOut` = the transfer's value if it did not end in an error
          - if `recipient` is `accountedFor`, then
            - `amountIn` = the transfer's value if it did not end in an error
          - if both are not true, there's an error in the calc as all transfers must have a sender or recipient that is `accountedFor`
        - `begBal` = the asset's balance before this transfer
        - `endBal` = the asset's balance after this transfer
        - if the reconciliation balances, then
          - return `true`
        - else
          - we've failed to reconcile using top level transactional and log data, we must descend into the trace data:
          - this is a last resort, we should not get here often
          - if this fails, we will create an implied transfer
          - we only decend into the trace data if the asset is ETH (why is this?)
          - `reconcileFlows_traces`:
            - reset all accounting values other than `gasOut` which is always correct at the receipt level
            - handle the special case of the `prefundIn` transfer
            - query for traces for this transaction
            - for each trace (note that there may be zero):
              - if it's a refund from a self destruct, make note of incoming ETH
              - if it is a smart contract that self destructed, make note of outgoing ETH
              - both of the above may be true
              - handle some weird cases where smart contracts may have bugs in them
              - handle miner and uncle miner rewards
            - if the transaction is reconciled, return true
            - else, we've failed to reconcile using trace data, we must create an implied transfer
        - we've concluded reconciling flows internal to the transaction itself (including possibly descending into trace data and possibly creating an implied transfer. We must now balance accross transactions.
        - `reconcileBalances`:
          - using `prevDifferent` and `nextDifferent` from the context...
          - each are `false` if the appearance is in the same block either after or before respectively.
          - BEOLB: balance of the asset at the end of the last block
          - BEOB: balance of the asset at the end of the block
          - begBalOut = BEOLB
          - endBalOut = BEOB
          - four cases:
            - block zero: balances are zero
            - both prev and next are a different block: use the balances
            - prev is different: use the begBal from the end of the last block and calculate the endBal
            - next is different: use the calculated beginning balance and the ending balance
            - neither is different: use the calcualted values
          - assign reconciliation type
        - The reconciliation should be finished now however, some transfers are 'phony'. (i.e., an event but no balance change). Correct for those.
    - after all of this work, the appearance should be reconciled. All that's left is to price it using Uniswap.

### Accounting for Other Assets
- There are, of course, methods of representing assets other than ERC20 tokens and ETH balances. All of these other methods, given that they are non-standard, are ignored by our system; however, these type of assets could be included if they become important enough. We strongly encourage the use of ERC20 tokens through support for the `getBalance` routine for representing assets on the Ethereum blockchain.
- Additionally, the software is open source, and we welcome contributions to the code base.
